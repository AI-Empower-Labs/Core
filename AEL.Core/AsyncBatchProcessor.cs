using System.Threading.Channels;

using AEL.Core.Extensions;

using Microsoft.Extensions.Logging;

namespace AEL.Core;

/// <summary>
/// Represents an asynchronous batch processor that processes input data in batches using
/// a user-defined function and communicates the results back to individual callers.
/// Usefull for processing large amounts of single items data that can be processed more
/// effectively in batches, for example for GPU workloads like ML/AI inference, embeddings,
/// external HTTP API's, rate limited services, image processing, search indexing, etc.
/// </summary>
/// <typeparam name="TIn">The type of the input elements to be processed.</typeparam>
/// <typeparam name="TOut">The type of the output elements generated by the processing function.</typeparam>
public sealed class AsyncBatchProcessor<TIn, TOut>(
	int batchSize,
	Func<TIn[], TOut[]> func,
	ILogger logger) : AsyncBackgroundService(logger)
{
	/// <summary>
	/// Represents an unbounded channel used for asynchronous communication
	/// between the producer and consumer within the <see cref="AsyncBatchProcessor{TIn, TOut}"/>.
	/// </summary>
	private readonly Channel<(TIn Value, TaskCompletionSource<TOut> TaskCompletionSource)> _channel =
		Channel.CreateUnbounded<(TIn, TaskCompletionSource<TOut>)>();

	/// Processes a single input asynchronously, enqueues it for batch processing,
	/// and returns a task that completes when the associated output is ready.
	/// <param name="value">
	/// The input value to be processed.
	/// </param>
	/// <param name="cancellationToken">
	/// A cancellation token to observe while waiting for the task to complete. Defaults to none.
	/// </param>
	/// <returns>
	/// A task that represents the asynchronous processing operation and contains the resulting output of the task.
	/// </returns>
	public async ValueTask<TOut> Process(TIn value,
		CancellationToken cancellationToken = default)
	{
		// Link the caller's cancellation to the task completion
		TaskCompletionSource<TOut> tcs = new(TaskCreationOptions.RunContinuationsAsynchronously);
		await using CancellationTokenRegistration tokenRegistration =
			cancellationToken.Register(() => tcs.TrySetCanceled(cancellationToken));

		// If cancellation is already requested, avoid enqueueing
		if (cancellationToken.IsCancellationRequested)
		{
			return await tcs.Task.ConfigureAwait(false);
		}

		if (!_channel.Writer.TryWrite((value, tcs)))
		{
			tcs.TrySetException(new InvalidOperationException("Failed to enqueue request."));
		}

		return await tcs.Task;
	}

	/// <summary>
	/// Signals that the asynchronous batch processor should complete its operation.
	/// </summary>
	/// <param name="error">
	/// Optional exception to indicate an error condition during the completion process.
	/// If null, the completion is considered successful; otherwise, the specified exception
	/// will propagate as the cause of the completion.
	/// </param>
	public void Complete(Exception? error = null)
	{
		if (error is null)
		{
			_channel.Writer.TryComplete();
		}
		else
		{
			_channel.Writer.TryComplete(error);
		}
	}

	/// <summary>
	/// Processes data in batches using the provided function, reading from the input channel
	/// until completion or cancellation.
	/// </summary>
	protected override async Task ExecuteAsync(CancellationToken stoppingToken)
	{
		await foreach (ICollection<(TIn Value, TaskCompletionSource<TOut> TaskCompletionSource)> batch in
			_channel.ReadAllBatchAggressive(batchSize, stoppingToken))
		{
			try
			{
				TOut[] embeddingOutputs = func(batch.Select(tuple => tuple.Value).ToArray());

				int count = Math.Min(embeddingOutputs.Length, batch.Count);
				int i = 0;
				foreach ((TIn Value, TaskCompletionSource<TOut> TaskCompletionSource) tuple in batch)
				{
					if (i < count)
					{
						tuple.TaskCompletionSource.TrySetResult(embeddingOutputs[i]);
					}
					else
					{
						tuple.TaskCompletionSource.TrySetException(
							new InvalidOperationException("Batch output count mismatch."));
					}

					i++;
				}
			}
			catch (OperationCanceledException oce)
			{
				foreach ((_, TaskCompletionSource<TOut> tcs) in batch)
				{
					tcs.TrySetCanceled(oce.CancellationToken);
				}
			}
			catch (Exception ex)
			{
				// Propagate the error to all tasks in the batch
				foreach ((_, TaskCompletionSource<TOut> tcs) in batch)
				{
					tcs.TrySetException(ex);
				}
			}
		}
	}
}
